"""RCS interface module for CVSGit."""

# Some observations about RCS + CVS, although I don't really know
# the RCS format...
#
# 1. The 'branch' keyword is normally absent (or empty?), but has
#    the value "1.1.1" for files that have been imported into the
#    vendor branch and never modified.  The 'head' keyword has the
#    value "1.1" in that case.

import os.path
import sys

from cvsgit.changeset import Change, FILE_ADDED, FILE_MODIFIED, \
    FILE_DELETED

# Our 'rcsparse' module is actually a simple copy of the RCS parser
# code from cvs2svn.
from cvsgit import rcsparse

REV_TIMESTAMP = 0
REV_AUTHOR = 1
REV_STATE = 2
REV_BRANCHES = 3
REV_NEXT = 4
REV_MODE = 5

class RCSFile(rcsparse.Sink):
    "Represents a single RCS file."

    def __init__(self, filename, encoding='iso8859-1'):
        """'encoding' sets the encoding assumed of log messages and
        delta text in RCS files.
        """
        self.filename = filename
        self.encoding = encoding
        self.parse()

    def parse(self):
        """Parse the RCS file to set the 'head', 'branch', 'revs' and
        'log' attributes.
        """
        f = file(os.path.join(self.filename), 'r')
        try:
            self.head = None
            self.branch = None
            self.revs = {}
            self.log = {}
            self.mode = ''              # XXX

            rcsparse.parse(f, self)
        finally:
            f.close()

    def revisions(self):
        """Yield all revision numbers from current HEAD backwards.
        """
        revision = self.head
        while revision != None:
            yield(revision)
            revision = self.revs[revision][REV_NEXT]

    def changes(self):
        """Yield Change objects for all revisions on HEAD

        The changes are generated by following the current head
        revision back to its origin.  The order of changes is thus
        from most recent to oldest.
        """
        for revision in self.revisions():
            rev = self.revs[revision]

            if rev[REV_STATE] == 'dead':
                if revision == '1.1':
                    # This file was initially added on a branch and so
                    # the initial trunk revision was marked 'dead'. We
                    # do not count this as a change since it wasn't
                    # added and hasn't existed before.
                    continue
                else:
                    filestatus = FILE_DELETED
            elif revision == '1.1.1.1' or revision == '1.1':
                if revision == '1.1' and rev[REV_BRANCHES] == ['1.1.1.1']:
                    self.log[revision] = self.log['1.1.1.1']
                filestatus = FILE_ADDED
            else:
                # XXX: Resurrections of dead revisions aren't flagged
                # as FILE_ADDED.
                filestatus = FILE_MODIFIED

            yield(Change(timestamp=rev[REV_TIMESTAMP],
                         author=rev[REV_AUTHOR],
                         log=self.log[revision],
                         filestatus=filestatus,
                         filename=self.filename,
                         revision=revision,
                         state=rev[REV_STATE],
                         mode=rev[REV_MODE]))

    # XXX only for debugging; remove later
    def _print_revision(self, revision):
        import time
        rev = self.revs[revision]
        print 'revision:', revision
        print '  timestamp:', time.strftime("%Y-%m-%d %H:%M", time.gmtime(rev[REV_TIMESTAMP]))
        print '  branches:', rev[REV_BRANCHES]
        print '  next:', rev[REV_NEXT]
        print '  state:', rev[REV_STATE]
        print '  log:', self.log[revision].splitlines()[0]

    # rcsparse.Sink methods:

    def set_head_revision(self, revision):
        self.head = revision

    def set_principal_branch(self, branch_name):
        self.branch = branch_name

    def set_expansion(self, mode):
        self.mode = mode

    def define_revision(self, revision, timestamp, author, state,
                        branches, next):
        self.revs[revision] = (timestamp, author, state, branches, next,
                               self.mode) # XXX

    def set_revision_info(self, revision, log, text):
        self.log[revision] = unicode(log, self.encoding)
