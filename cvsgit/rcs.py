"""RCS interface module for CVSGit."""

import os.path

from cvsgit.changeset import Change, FILE_ADDED, FILE_MODIFIED, \
    FILE_DELETED

# Our 'rcsparse' module is actually a simple copy of the RCS parser
# code from cvs2svn.
from cvsgit import rcsparse

REV_TIMESTAMP = 0
REV_AUTHOR = 1
REV_STATE = 2
REV_BRANCHES = 3
REV_NEXT = 4
REV_MODE = 5

class RCSFile(rcsparse.Sink):
    "Represents a single RCS file."

    def __init__(self, filename, encoding='iso8859-1'):
        """'encoding' sets the encoding assumed of log messages and
        delta text in RCS files."""
        self.filename = filename
        self.encoding = encoding
        self.parse()

    def parse(self):
        """Parse the RCS file to set the 'head', 'branch', 'revs' and
        'log' attributes."""

        f = file(os.path.join(self.filename), 'r')
        try:
            self.head = None
            self.branch = None
            self.revs = {}
            self.log = {}
            self.mode = ''              # XXX

            rcsparse.parse(f, self)
        finally:
            f.close()

    def changes(self):
        """Yield Change objects corresponding to all trunk revisions,
        generated by following the current head revision of the
        default branch back to its origin.  The order of changes is
        thus from most recent to oldest.
        """

        #print self.filename
        for revision in self.revision_trail(self.default_branch()):
            rev = self.revs[revision]
            #self._print_revision(revision)

            if rev[REV_STATE] == 'dead':
                if revision == '1.1':
                    # This file was initially added on a branch and so
                    # the initial trunk revision was marked 'dead'. We
                    # do not count this as a change since it wasn't
                    # added and hasn't existed before.
                    continue
                else:
                    filestatus = FILE_DELETED
            elif revision == '1.1.1.1' or revision == '1.1':
                filestatus = FILE_ADDED
            else:
                # XXX: Resurrections of dead revisions aren't flagged
                # as FILE_ADDED.
                filestatus = FILE_MODIFIED
            #print filestatus

            yield(Change(timestamp=rev[REV_TIMESTAMP],
                         author=rev[REV_AUTHOR],
                         log=self.log[revision],
                         filestatus=filestatus,
                         filename=self.filename,
                         revision=revision,
                         state=rev[REV_STATE],
                         mode=rev[REV_MODE]))

    def default_branch(self):
        """Return the default branch, normally either '1' or the
        vendor branch '1.1.1'."""

        if self.branch:
            # Usually the branch will be '1.1.1' in this case.
            assert(self.branch == '1.1.1')
            return self.branch
        else:
            # Under normal circumstances the branch will always be '1'.
            branch = self.head.rsplit('.', 1)[0]
            assert(branch == '1')
            return branch

    def revision_trail(self, branch):
        """Yield the complete history of a branch, beginning at the
        head revision of 'branch' and going backwards, tracing the
        previous revisions on that branch and the revision of the
        branch ancestors up to the origin."""

        while branch:
            for revision in self.branch_revisions(branch):
                if revision == '1.1' and '1.1.1.1' in \
                        self.revs[revision][REV_BRANCHES] and \
                        self.log[revision] == 'Initial revision':
                    # TODO: Time stamps of revisions 1.1 and 1.1.1.1
                    # revision should also match, so verify?
                    # This revision seems to have been created by an
                    # import into the vendor branch.  The actual log
                    # message is that of the initial revision on the
                    # vendor branch.
                    yield('1.1.1.1')
                    return
                elif revision == '1.1.1.1':
                    # Since the initial vendor branch revision
                    # contains the real log message for the initial
                    # import, there is no need to trace the vendor
                    # branch back to the 1.1 revision.
                    yield(revision)
                    return
                else:
                    yield(revision)

            # Continue tracing the history of the branch point.
            branch = self.branch_point(branch)

    def branch_revisions(self, branch):
        """Yield all revisions of the branch, from the highest
        revision number to the lowest."""

        count = self.branch_revision_count(branch)
        while count > 0:
            yield(branch + '.' + str(count))
            count -= 1

    def branch_revision_count(self, branch):
        """Return the number of revisions on the given branch."""

        count = 0
        for revision in self.revs.keys():
            rbranch, rnumber = revision.rsplit('.', 1)
            if rbranch == branch:
                count += 1
        return count

    def branch_point(self, branch):
        """Return the ancestor revision number of the given branch or
        None if the branch has no ancestor."""

        initial = branch + '.1'
        for revision in self.revs.keys():
            rev = self.revs[revision]
            for rbranch in rev[REV_BRANCHES]:
                if rbranch == initial:
                    return revision
        return None

    # XXX only for debugging; remove later
    def _print_revision(self, revision):
        import time
        rev = self.revs[revision]
        print 'revision:', revision
        print '  timestamp:', time.strftime("%Y-%m-%d %H:%M", time.gmtime(rev[REV_TIMESTAMP]))
        print '  branches:', rev[REV_BRANCHES]
        print '  next:', rev[REV_NEXT]
        print '  state:', rev[REV_STATE]
        print '  log:', self.log[revision].splitlines()[0]

    # XXX only for debugging; remove later
    def _revisions(self):
        for revision in self.revs.keys():
            yield(revision)

    # rcsparse.Sink methods:

    def set_head_revision(self, revision):
        self.head = revision

    def set_principal_branch(self, branch_name):
        self.branch = branch_name

    def set_expansion(self, mode):
        self.mode = mode

    def define_revision(self, revision, timestamp, author, state,
                        branches, next):
        self.revs[revision] = (timestamp, author, state, branches, next,
                               self.mode) # XXX

    def set_revision_info(self, revision, log, text):
        self.log[revision] = unicode(log, self.encoding)
