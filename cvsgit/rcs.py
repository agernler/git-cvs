"""RCS interface module for CVSGit."""

# Some observations about RCS + CVS, although I don't really know
# that much about the RCS format or the CVS usage of it...
#
# 1. The 'branch' keyword is normally absent (or empty?), but has
#    the value "1.1.1" for files that have been imported into the
#    vendor branch and never modified.  The 'head' keyword has the
#    value "1.1" in that case.
#
# 2. When checking out files on trunk via date that were imported
#    in a vendor branch, cvs expands the Id keyword to "1.1.1.1"
#    if the date matches exactly, and to "1.1" if the date is one
#    second or more after the exact date of the import.

import os.path
import sys

from cvsgit.changeset import Change, FILE_ADDED, FILE_MODIFIED, \
    FILE_DELETED

# Our 'rcsparse' module is actually a simple copy of the RCS parser
# code from cvs2svn.
from cvsgit import rcsparse

REV_TIMESTAMP = 0
REV_AUTHOR = 1
REV_STATE = 2
REV_BRANCHES = 3
REV_NEXT = 4
REV_MODE = 5

class RCSFile(rcsparse.Sink):
    "Represents a single RCS file."

    def __init__(self, filename, encoding='iso8859-1'):
        """'encoding' sets the encoding assumed of log messages and
        delta text in RCS files.
        """
        self.filename = filename
        self.encoding = encoding
        self.parse()

    def parse(self):
        """Parse the RCS file to set the 'head', 'branch', 'revs' and
        'log' attributes.
        """
        f = file(os.path.join(self.filename), 'r')
        try:
            self.head = None
            self.branch = None
            self.revs = {}
            self.log = {}
            self.mode = ''              # XXX

            rcsparse.parse(f, self)
        finally:
            f.close()

    def revisions(self):
        """Yield all revision numbers from current HEAD backwards.
        """
        revision = self.head
        while revision != None:
            # See the comment at the top of this file.  This may not always
            # result in the same Id keyword expansion that cvs does for the
            # initial revision of an imported file, but it seems to be what
            # Id expanded to in the checked out file that resulted in 1.2.
            branches = self.revs[revision][REV_BRANCHES]
            if revision == '1.1' and '1.1.1.1' in branches:
                revision = '1.1.1.1'

            yield(revision)
            revision = self.revs[revision][REV_NEXT]

    def changes(self):
        """Yield Change objects for all revisions on HEAD

        The changes are generated by following the current head
        revision back to its origin.  The order of changes is thus
        from most recent to oldest.
        """
        for revision in self.revisions():
            rev = self.revs[revision]

            if rev[REV_STATE] == 'dead':
                if revision == '1.1':
                    # This file was initially added on a branch and so
                    # the initial trunk revision was marked 'dead'. We
                    # do not count this as a change since it wasn't
                    # added and hasn't existed before.
                    continue
                else:
                    filestatus = FILE_DELETED
            elif rev[REV_NEXT] == None:
                filestatus = FILE_ADDED
            else:
                # XXX: Resurrections of dead revisions aren't flagged
                # as FILE_ADDED.
                filestatus = FILE_MODIFIED

            # The log message for an initial import is actually in
            # the initial vendor branch revision.
            if revision == '1.1' and '1.1.1.1' in rev[REV_BRANCHES]:
                log = self.log['1.1.1.1']
            else:
                log = self.log[revision]

            yield(Change(timestamp=rev[REV_TIMESTAMP],
                         author=rev[REV_AUTHOR],
                         log=log,
                         filestatus=filestatus,
                         filename=self.filename,
                         revision=revision,
                         state=rev[REV_STATE],
                         mode=rev[REV_MODE]))

    # XXX only for debugging; remove later
    def _print_revision(self, revision):
        import time
        rev = self.revs[revision]
        print 'revision:', revision
        print '  timestamp:', time.strftime("%Y-%m-%d %H:%M", time.gmtime(rev[REV_TIMESTAMP]))
        print '  branches:', rev[REV_BRANCHES]
        print '  next:', rev[REV_NEXT]
        print '  state:', rev[REV_STATE]
        print '  log:', self.log[revision].splitlines()[0]

    # rcsparse.Sink methods:

    def set_head_revision(self, revision):
        self.head = revision

    def set_principal_branch(self, branch_name):
        self.branch = branch_name

    def set_expansion(self, mode):
        self.mode = mode

    def define_revision(self, revision, timestamp, author, state,
                        branches, next):
        self.revs[revision] = (timestamp, author, state, branches, next,
                               self.mode) # XXX

    def set_revision_info(self, revision, log, text):
        self.log[revision] = unicode(log, self.encoding)
